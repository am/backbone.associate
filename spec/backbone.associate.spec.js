// Generated by CoffeeScript 1.4.0
(function() {
  var Backbone, _,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof window == 'undefined') {
    Backbone = require('backbone');
    _ = require('underscore');

    require('./helper');
    require('../src/backbone.associate');
  }

  var M = Backbone.Model.extend({}),
      N = Backbone.Model.extend({}),
      O = Backbone.Model.extend({}),
      C = Backbone.Collection.extend({
        model: N
      });

  describe('association', function() {
    beforeEach(function() {
      this.modelA = M;
      this.modelB = N;
      this.modelC = O;
      this.collectionB = C;
      this.associations = {
        one: {
          type: this.modelB
        },
        manies: {
          type: this.collectionB
        }
      };
      Backbone.associate(this.modelA, this.associations);
      return this.parent = new this.modelA;
    });

    afterEach(function() {
      return Backbone.dissociate(this.modelA);
    });

    describe('A model with associations', function() {
      it('should have accessors for each association', function() {
        var association, key, _ref, _results;
        _ref = this.associations;
        _results = [];
        for (key in _ref) {
          association = _ref[key];
          _results.push(expect(_.isFunction(this.parent[key])).toBeTruthy());
        }
        return _results;
      });
      it('should extend dependent methods', function() {
        var meth, _i, _len, _ref, _results;
        _ref = ['initialize', 'set', 'toJSON'];
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          meth = _ref[_i];
          _results.push(expect(this.parent[meth]).not.toEqual(Backbone.Model.prototype[meth]));
        }
        return _results;
      });
    });
    describe('When model is initialized', function() {
      it('should build empty associates if attributes were not provided', function() {
        var association, key, _ref, _results;
        _ref = this.associations;
        _results = [];
        for (key in _ref) {
          association = _ref[key];
          _results.push(expect(this.parent.get(key) instanceof association.type).toBeTruthy());
        }
        return _results;
      });
      it('should not overwrite existing associates', function() {
        var association, expected, key, model, _ref, _results;
        expected = {
          one: {
            foo: 'bar'
          }
        };
        model = new this.modelA(expected);
        _ref = this.associations;
        _results = [];
        for (key in _ref) {
          association = _ref[key];
          if (_.has(expected, key)) {
            _results.push(expect(model[key]().attributes).toEqual(expected[key]));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      it('should use defaults to populate associates', function() {
        var association, defaults, expected, key, model, _ref;
        expected = {
          one: {
            foo: 'bar'
          }
        };
        defaults = this.modelA.prototype.defaults;
        this.modelA.prototype.defaults = expected;
        model = new this.modelA({});
        _ref = this.associations;
        for (key in _ref) {
          association = _ref[key];
          if (_.has(expected, key)) {
            expect(model[key]().attributes).toEqual(expected[key]);
          }
        }
        return this.modelA.prototype.defaults = defaults;
      });
      it('should preserves references to associates', function() {
        var modelA, modelB;
        modelB = new this.modelB;
        modelA = new this.modelA({
          one: modelB
        });
        return expect(modelA.one() === modelB).toBeTruthy();
      });
      it('should recurse through associated objects', function() {
        var fixture, fooVal;
        Backbone.associate(this.modelB, {
          two: {
            type: this.modelC
          }
        });
        fooVal = 'bar';
        fixture = {
          one: {
            two: {
              foo: fooVal
            }
          }
        };
        this.parent = new this.modelA(fixture);
        expect(this.parent.one().two().get('foo')).toEqual(fooVal);
        return Backbone.dissociate(this.modelB);
      });
    });
    describe('When a model property is set by key and value', function() {
      it('should accept a key and its value as arguments', function() {
        this.parent.set('a', 'foo');
        return expect(this.parent.attributes.a).toEqual('foo');
      });
      it('should set one-to-one relations', function() {
        this.parent.set('one', {
          foo: 'bar'
        });
        return expect(this.parent.one().attributes.foo).toEqual('bar');
      });
      it('should set one-to-many relations', function() {
        this.parent.set('manies', [
          {
            id: 'foo'
          }
        ]);
        return expect(this.parent.manies().get('foo')).toBeDefined();
      });
    });
    describe('When properties on a model are set by hash', function() {
      beforeEach(function() {
        return this.fixture = {
          a: 'foo',
          b: 42,
          c: {
            hello: 'world'
          },
          one: {
            foo: 'bar'
          },
          manies: [
            {
              id: 'foo'
            }
          ]
        };
      });
      it('should not affect unrelated keys', function() {
        var expected, key, _ref, _results;
        this.parent.set(this.fixture);
        _ref = this.fixture;
        _results = [];
        for (key in _ref) {
          expected = _ref[key];
          if (!_.include(_.keys(this.associations), key)) {
            _results.push(expect(this.parent.attributes[key]).toEqual(expected));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      it('should fill in associations when no attributes are provided', function() {
        var association, key, _ref, _results;
        this.parent.set(this.fixture);
        _ref = this.associations;
        _results = [];
        for (key in _ref) {
          association = _ref[key];
          _results.push(expect(this.parent.attributes[key] instanceof association.type).toBeTruthy());
        }
        return _results;
      });
      it('should not change original arguments', function() {
        var expected;
        expected = _.clone(this.fixture);
        this.parent.set(expected);
        return expect(_.isEqual(this.fixture, expected)).toBeTruthy();
      });
      it('should not clobber existing model relations', function() {
        var expected, expectedAttr;
        this.parent.set(this.fixture);
        expected = this.parent.one();
        expectedAttr = this.parent.one().get('foo');
        this.parent.set({
          a: 'foobar'
        });
        expect(this.parent.one()).toEqual(expected);
        return expect(this.parent.one().get('foo')).toEqual(expectedAttr);
      });
      it('should not clobber existing collection relations', function() {
        var expected, expectedLength;
        this.parent.set(this.fixture);
        expected = this.parent.manies();
        expectedLength = this.parent.manies().length;
        this.parent.set({
          a: 'foobar'
        });
        expect(this.parent.manies()).toEqual(expected);
        return expect(this.parent.manies().length).toEqual(expectedLength);
      });
      it('should parse model relations', function() {
        var expected, key, _ref, _results;
        this.parent.set(this.fixture);
        _ref = this.fixture;
        _results = [];
        for (key in _ref) {
          expected = _ref[key];
          if (_.has(this.parent._associations, key) && this.parent[key]() instanceof Backbone.Model) {
            expect(this.parent[key]() instanceof this.associations[key].type).toBeTruthy();
            _results.push(expect(this.parent[key]().get('foo')).toEqual(this.fixture[key].foo));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      it('should parse collection relations', function() {
        var expected, key, _ref, _results;
        this.parent.set(this.fixture);
        _ref = this.fixture;
        _results = [];
        for (key in _ref) {
          expected = _ref[key];
          if (_.has(this.parent._associations, key) && this.parent[key]() instanceof Backbone.Collection) {
            expect(this.parent[key]() instanceof this.associations[key].type).toBeTruthy();
            _results.push(expect(this.parent[key]().first().get('foo')).toEqual(this.fixture[key][0].foo));
          } else {
            _results.push(void 0);
          }
        }
        return _results;
      });
      it('should preserve passed model references', function() {
        var model;
        model = new this.modelB;
        this.parent.set(_.extend(this.fixture, {
          one: model
        }));
        return expect(this.parent.one() === model).toBeTruthy();
      });
      it('should preserve passed collection references', function() {
        var collection;
        collection = new this.collectionB;
        this.parent.set(_.extend(this.fixture, {
          manies: collection
        }));
        return expect(this.parent.manies() === collection).toBeTruthy();
      });
      it('should preserve references to associated models', function() {
        var expected;
        expected = this.parent.one();
        this.parent.set({
          one: {
            'foo': 'bar'
          }
        });
        return expect(this.parent.one()).toEqual(expected);
      });
      it('should preserve references to associated collections', function() {
        var expected;
        expected = this.parent.manies();
        this.parent.set([
          {
            id: 'mixcoatl',
            foo: 'bar'
          }
        ]);
        return expect(this.parent.manies()).toEqual(expected);
      });
      it('should recurses for nested models', function() {
        var fixture, fooVal, klass, model;
        klass = Backbone.Model.extend({});
        Backbone.associate(this.modelB, {
          two: {
            type: klass
          }
        });
        fooVal = 'bar';
        fixture = {
          one: {
            two: {
              foo: fooVal
            }
          }
        };
        model = new this.modelA;
        model.set(fixture);
        expect(model.one().two().get('foo')).toEqual(fooVal);
        return Backbone.dissociate(this.modelB);
      });
      it('should recurse for nested collections', function() {
        var fixture, fooVal, klass, model;

        klass = Backbone.Collection.extend({ model: this.modelC });

        Backbone.associate(this.modelB, { two: { type: klass } });

        fooVal = 'bar';

        fixture = {
          one: {
            two: [{ id: 'three', foo: fooVal }]
          }
        };

        model = new this.modelA;
        model.set(fixture);
        expect(model.one().two().get('three').get('foo')).toEqual(fooVal);
        return Backbone.dissociate(this.modelB);
      });
    });

    describe('When serializing model associations', function() {

      it('should convert models to attribute hash', function() {
        var result, 
            expected = { foo: 'bar' };
        this.parent.one().set(expected);
        result = this.parent.toJSON();
        return expect(result.one).toEqual(expected);
      });

      it('should convert collections to model arrays', function() {
        var result,
            expected = [{ id: 'foo' }];

        this.parent.manies().reset(expected);
        result = this.parent.toJSON();
        return expect(result.manies).toEqual(expected);
      });
    });

    describe('When an association is inherited', function() {

      it('should be defined for the child', function() {
        var modelAChild = this.modelA.extend({}),
            child = new modelAChild;

        expect(child.one() instanceof this.modelB).toBeTruthy();
        return expect(child.manies() instanceof this.collectionB).toBeTruthy();
      });

    });
  });

}).call(this);
